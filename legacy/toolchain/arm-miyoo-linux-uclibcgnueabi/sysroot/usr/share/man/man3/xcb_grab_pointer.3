.TH xcb_grab_pointer 3  "libxcb 1.12" "X Version 11" "XCB Requests"
.ad l
.SH NAME
xcb_grab_pointer \- Grab the pointer
.SH SYNOPSIS
.hy 0
.B #include <xcb/xproto.h>
.SS Request function
.HP
xcb_grab_pointer_cookie_t \fBxcb_grab_pointer\fP(xcb_connection_t\ *\fIconn\fP, uint8_t\ \fIowner_events\fP, xcb_window_t\ \fIgrab_window\fP, uint16_t\ \fIevent_mask\fP, uint8_t\ \fIpointer_mode\fP, uint8_t\ \fIkeyboard_mode\fP, xcb_window_t\ \fIconfine_to\fP, xcb_cursor_t\ \fIcursor\fP, xcb_timestamp_t\ \fItime\fP);
.PP
.SS Reply datastructure
.nf
.sp
typedef struct xcb_grab_pointer_reply_t {
    uint8_t  \fIresponse_type\fP;
    uint8_t  \fIstatus\fP;
    uint16_t \fIsequence\fP;
    uint32_t \fIlength\fP;
} \fBxcb_grab_pointer_reply_t\fP;
.fi
.SS Reply function
.HP
xcb_grab_pointer_reply_t *\fBxcb_grab_pointer_reply\fP(xcb_connection_t\ *\fIconn\fP, xcb_grab_pointer_cookie_t\ \fIcookie\fP, xcb_generic_error_t\ **\fIe\fP);
.br
.hy 1
.SH REQUEST ARGUMENTS
.IP \fIconn\fP 1i
The XCB connection to X11.
.IP \fIowner_events\fP 1i
If 1, the \fIgrab_window\fP will still get the pointer events. If 0, events are not
reported to the \fIgrab_window\fP.
.IP \fIgrab_window\fP 1i
Specifies the window on which the pointer should be grabbed.
.IP \fIevent_mask\fP 1i
Specifies which pointer events are reported to the client.

TODO: which values?
.IP \fIpointer_mode\fP 1i
One of the following values:
.RS 1i
.IP \fIXCB_GRAB_MODE_SYNC\fP 1i
The state of the keyboard appears to freeze: No further keyboard events are
generated by the server until the grabbing client issues a releasing
\fIAllowEvents\fP request or until the keyboard grab is released.
.IP \fIXCB_GRAB_MODE_ASYNC\fP 1i
Keyboard event processing continues normally.
.RE
.RS 1i


.RE
.IP \fIkeyboard_mode\fP 1i
One of the following values:
.RS 1i
.IP \fIXCB_GRAB_MODE_SYNC\fP 1i
The state of the keyboard appears to freeze: No further keyboard events are
generated by the server until the grabbing client issues a releasing
\fIAllowEvents\fP request or until the keyboard grab is released.
.IP \fIXCB_GRAB_MODE_ASYNC\fP 1i
Keyboard event processing continues normally.
.RE
.RS 1i


.RE
.IP \fIconfine_to\fP 1i
Specifies the window to confine the pointer in (the user will not be able to
move the pointer out of that window).

The special value \fIXCB_NONE\fP means don't confine the pointer.
.IP \fIcursor\fP 1i
Specifies the cursor that should be displayed or \fIXCB_NONE\fP to not change the
cursor.
.IP \fItime\fP 1i
The time argument allows you to avoid certain circumstances that come up if
applications take a long time to respond or if there are long network delays.
Consider a situation where you have two applications, both of which normally
grab the pointer when clicked on. If both applications specify the timestamp
from the event, the second application may wake up faster and successfully grab
the pointer before the first application. The first application then will get
an indication that the other application grabbed the pointer before its request
was processed.

The special value \fIXCB_CURRENT_TIME\fP will be replaced with the current server
time.
.SH REPLY FIELDS
.IP \fIresponse_type\fP 1i
The type of this reply, in this case \fIXCB_GRAB_POINTER\fP. This field is also present in the \fIxcb_generic_reply_t\fP and can be used to tell replies apart from each other.
.IP \fIsequence\fP 1i
The sequence number of the last request processed by the X11 server.
.IP \fIlength\fP 1i
The length of the reply, in words (a word is 4 bytes).
.IP \fIstatus\fP 1i
One of the following values:
.RS 1i
.IP \fIXCB_GRAB_STATUS_SUCCESS\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_ALREADY_GRABBED\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_INVALID_TIME\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_NOT_VIEWABLE\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_FROZEN\fP 1i
TODO: NOT YET DOCUMENTED.
.RE
.RS 1i
TODO: NOT YET DOCUMENTED.
.RE
.SH DESCRIPTION
Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.
.SH RETURN VALUE
Returns an \fIxcb_grab_pointer_cookie_t\fP. Errors have to be handled when calling the reply function \fIxcb_grab_pointer_reply\fP.

If you want to handle errors in the event loop instead, use \fIxcb_grab_pointer_unchecked\fP. See \fBxcb-requests(3)\fP for details.
.SH ERRORS
.IP \fIxcb_value_error_t\fP 1i
TODO: reasons?
.IP \fIxcb_window_error_t\fP 1i
The specified \fIwindow\fP does not exist.
.SH EXAMPLE
.nf
.sp
/*
 * Grabs the pointer actively
 *
 */
void my_example(xcb_connection_t *conn, xcb_screen_t *screen, xcb_cursor_t cursor) {
    xcb_grab_pointer_cookie_t cookie;
    xcb_grab_pointer_reply_t *reply;

    cookie = xcb_grab_pointer(
        conn,
        false,               /* get all pointer events specified by the following mask */
        screen->root,        /* grab the root window */
        XCB_NONE,            /* which events to let through */
        XCB_GRAB_MODE_ASYNC, /* pointer events should continue as normal */
        XCB_GRAB_MODE_ASYNC, /* keyboard mode */
        XCB_NONE,            /* confine_to = in which window should the cursor stay */
        cursor,              /* we change the cursor to whatever the user wanted */
        XCB_CURRENT_TIME
    );

    if ((reply = xcb_grab_pointer_reply(conn, cookie, NULL))) {
        if (reply->status == XCB_GRAB_STATUS_SUCCESS)
            printf("successfully grabbed the pointer\\n");
        free(preply);
    }
}
.fi
.SH SEE ALSO
.BR xcb-requests (3),
.BR xcb-examples (3),
.BR xcb_grab_keyboard (3)
.SH AUTHOR
Generated from xproto.xml. Contact xcb@lists.freedesktop.org for corrections and improvements.
