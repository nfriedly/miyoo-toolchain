.TH xcb_grab_keyboard 3  "libxcb 1.12" "X Version 11" "XCB Requests"
.ad l
.SH NAME
xcb_grab_keyboard \- Grab the keyboard
.SH SYNOPSIS
.hy 0
.B #include <xcb/xproto.h>
.SS Request function
.HP
xcb_grab_keyboard_cookie_t \fBxcb_grab_keyboard\fP(xcb_connection_t\ *\fIconn\fP, uint8_t\ \fIowner_events\fP, xcb_window_t\ \fIgrab_window\fP, xcb_timestamp_t\ \fItime\fP, uint8_t\ \fIpointer_mode\fP, uint8_t\ \fIkeyboard_mode\fP);
.PP
.SS Reply datastructure
.nf
.sp
typedef struct xcb_grab_keyboard_reply_t {
    uint8_t  \fIresponse_type\fP;
    uint8_t  \fIstatus\fP;
    uint16_t \fIsequence\fP;
    uint32_t \fIlength\fP;
} \fBxcb_grab_keyboard_reply_t\fP;
.fi
.SS Reply function
.HP
xcb_grab_keyboard_reply_t *\fBxcb_grab_keyboard_reply\fP(xcb_connection_t\ *\fIconn\fP, xcb_grab_keyboard_cookie_t\ \fIcookie\fP, xcb_generic_error_t\ **\fIe\fP);
.br
.hy 1
.SH REQUEST ARGUMENTS
.IP \fIconn\fP 1i
The XCB connection to X11.
.IP \fIowner_events\fP 1i
If 1, the \fIgrab_window\fP will still get the pointer events. If 0, events are not
reported to the \fIgrab_window\fP.
.IP \fIgrab_window\fP 1i
Specifies the window on which the pointer should be grabbed.
.IP \fItime\fP 1i
Timestamp to avoid race conditions when running X over the network.

The special value \fIXCB_CURRENT_TIME\fP will be replaced with the current server
time.
.IP \fIpointer_mode\fP 1i
One of the following values:
.RS 1i
.IP \fIXCB_GRAB_MODE_SYNC\fP 1i
The state of the keyboard appears to freeze: No further keyboard events are
generated by the server until the grabbing client issues a releasing
\fIAllowEvents\fP request or until the keyboard grab is released.
.IP \fIXCB_GRAB_MODE_ASYNC\fP 1i
Keyboard event processing continues normally.
.RE
.RS 1i


.RE
.IP \fIkeyboard_mode\fP 1i
One of the following values:
.RS 1i
.IP \fIXCB_GRAB_MODE_SYNC\fP 1i
The state of the keyboard appears to freeze: No further keyboard events are
generated by the server until the grabbing client issues a releasing
\fIAllowEvents\fP request or until the keyboard grab is released.
.IP \fIXCB_GRAB_MODE_ASYNC\fP 1i
Keyboard event processing continues normally.
.RE
.RS 1i


.RE
.SH REPLY FIELDS
.IP \fIresponse_type\fP 1i
The type of this reply, in this case \fIXCB_GRAB_KEYBOARD\fP. This field is also present in the \fIxcb_generic_reply_t\fP and can be used to tell replies apart from each other.
.IP \fIsequence\fP 1i
The sequence number of the last request processed by the X11 server.
.IP \fIlength\fP 1i
The length of the reply, in words (a word is 4 bytes).
.IP \fIstatus\fP 1i
One of the following values:
.RS 1i
.IP \fIXCB_GRAB_STATUS_SUCCESS\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_ALREADY_GRABBED\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_INVALID_TIME\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_NOT_VIEWABLE\fP 1i
TODO: NOT YET DOCUMENTED.
.IP \fIXCB_GRAB_STATUS_FROZEN\fP 1i
TODO: NOT YET DOCUMENTED.
.RE
.RS 1i
TODO: NOT YET DOCUMENTED.
.RE
.SH DESCRIPTION
Actively grabs control of the keyboard and generates FocusIn and FocusOut
events. Further key events are reported only to the grabbing client.

Any active keyboard grab by this client is overridden. If the keyboard is
actively grabbed by some other client, \fIAlreadyGrabbed\fP is returned. If
\fIgrab_window\fP is not viewable, \fIGrabNotViewable\fP is returned. If the keyboard
is frozen by an active grab of another client, \fIGrabFrozen\fP is returned. If the
specified \fItime\fP is earlier than the last-keyboard-grab time or later than the
current X server time, \fIGrabInvalidTime\fP is returned. Otherwise, the
last-keyboard-grab time is set to the specified time.
.SH RETURN VALUE
Returns an \fIxcb_grab_keyboard_cookie_t\fP. Errors have to be handled when calling the reply function \fIxcb_grab_keyboard_reply\fP.

If you want to handle errors in the event loop instead, use \fIxcb_grab_keyboard_unchecked\fP. See \fBxcb-requests(3)\fP for details.
.SH ERRORS
.IP \fIxcb_value_error_t\fP 1i
TODO: reasons?
.IP \fIxcb_window_error_t\fP 1i
The specified \fIwindow\fP does not exist.
.SH EXAMPLE
.nf
.sp
/*
 * Grabs the keyboard actively
 *
 */
void my_example(xcb_connection_t *conn, xcb_screen_t *screen) {
    xcb_grab_keyboard_cookie_t cookie;
    xcb_grab_keyboard_reply_t *reply;

    cookie = xcb_grab_keyboard(
        conn,
        true,                /* report events */
        screen->root,        /* grab the root window */
        XCB_CURRENT_TIME,
        XCB_GRAB_MODE_ASYNC, /* process events as normal, do not require sync */
        XCB_GRAB_MODE_ASYNC
    );

    if ((reply = xcb_grab_keyboard_reply(conn, cookie, NULL))) {
        if (reply->status == XCB_GRAB_STATUS_SUCCESS)
            printf("successfully grabbed the keyboard\\n");

        free(reply);
    }
}
.fi
.SH SEE ALSO
.BR xcb-requests (3),
.BR xcb-examples (3),
.BR xcb_grab_pointer (3)
.SH AUTHOR
Generated from xproto.xml. Contact xcb@lists.freedesktop.org for corrections and improvements.
